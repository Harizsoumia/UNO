
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.File;
import java.io.IOException;
import javax.swing.JComponent;
// Ces imports ne sont plus nécessaires pour le chargement d'images dans cette classe
// import javax.imageio.ImageIO;
// import java.util.HashMap;
// import java.util.Map;


public class GameViewWithJLayeredPane extends JFrame {

    private GamePanel mainPanel;
    private int numPlayers;
    // Noms par défaut des joueurs
    private String[] playerNames = {"Vous", "Adversaire 1", "Adversaire 2", "Adversaire 3"};

    // Constantes de la vue
    private static final int FRAME_WIDTH = 900;
    private static final int FRAME_HEIGHT = 700;
    // Dimensions souhaitées pour les cartes affichées
    private static final int CARD_WIDTH = 70;
    private static final int CARD_HEIGHT = 100;
    // Angles pour l'effet éventail (en degrés)
    private static final int FAN_ANGLE = 40; // angle total de l'éventail

    // Instance du loader d'images de cartes
    private CardImageLoader imageLoader;

    // Constantes pour simuler les cartes (à remplacer par un modèle de jeu réel)
     private static final Color[] CARD_COLORS = {Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE, Color.RED, Color.YELLOW, Color.GREEN};
     private static final String[] CARD_VALUES = {"1", "2", "3", "4", "5", "6", "7"};
     private static final String[] CARD_TYPES = {"nombre", "nombre", "nombre", "nombre",
                                                  "nombre", "nombre", "nombre"};
    // Ajoutez des cartes spéciales pour les tests si vous avez les images
    // private static final Color[] CARD_COLORS = {Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE, null, null, Color.RED}; // null pour wild/plus4
    // private static final String[] CARD_VALUES = {"1", "Skip", "Reverse", "Draw Two", "", "", "0"}; // "" pour wild/plus4
    // private static final String[] CARD_TYPES = {"nombre", "passe", "inversion", "plus2", "wild", "plus4", "nombre"};


    public GameViewWithJLayeredPane(int numPlayers, String[] customPlayerNames) {
        if (numPlayers < 2 || numPlayers > 4) {
            throw new IllegalArgumentException("Le nombre de joueurs doit être entre 2 et 4.");
        }
        this.numPlayers = numPlayers;

        // Utiliser les noms personnalisés s'ils sont fournis
        if (customPlayerNames != null && customPlayerNames.length >= numPlayers) {
            for (int i = 0; i < numPlayers; i++) {
                this.playerNames[i] = customPlayerNames[i];
            }
        }

        // Instancier le loader d'images
        this.imageLoader = new CardImageLoader(30, 30, "C:\\Users\\manel\\Downloads\\cards.zip\\cards");

        setTitle("Jeu UNO - Cartes en Éventail avec Images (Separated)");
        setSize(FRAME_WIDTH, FRAME_HEIGHT);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        mainPanel = new GamePanel();
        mainPanel.setLayout(new GridBagLayout());
        add(mainPanel);

        setupLayout();

        // Couleur de fond initiale (tapis de jeu)
        mainPanel.setBackgroundColor(new Color(0, 100, 0)); // Vert foncé comme un tapis de jeu

        setVisible(true);
    }

    // Panneau principal gérant la couleur de fond
    class GamePanel extends JPanel {
        private Color bgColor;

        public void setBackgroundColor(Color color) {
            this.bgColor = color;
            repaint(); // Redessiner le panneau pour appliquer la nouvelle couleur
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g); // Peindre d'abord les composants enfants

            // Peindre le fond avec la couleur définie PAR-DESSUS le fond par défaut de JPanel
            // Si vous voulez un fond uni SANS les composants en dessous, retirez super.paintComponent(g);
            // Mais pour GridBagLayout, il faut généralement laisser super.paintComponent.
            // On peut aussi setBackground(bgColor) directement et laisser Swing gérer,
            // mais cette approche avec paintComponent donne plus de contrôle.
            if (bgColor != null) {
                 g.setColor(bgColor);
                 g.fillRect(0, 0, getWidth(), getHeight());
            }

            // Possibilité d'ajouter d'autres décorations sur le tapis de jeu ici
        }
    }

    private void setupLayout() {
        GridBagConstraints gbc = new GridBagConstraints();

        // --- Zone Centrale (Pioche/Défausse) ---
        JPanel centerPanel = setupCenterPanel();
        gbc.gridx = 1;
        gbc.gridy = 1;
        gbc.weightx = 0.5;
        gbc.weighty = 0.5;
        gbc.fill = GridBagConstraints.BOTH;
        mainPanel.add(centerPanel, gbc);

        // --- Panneaux des Joueurs ---
        gbc.weightx = 0.1;
        gbc.weighty = 0.1;
        gbc.fill = GridBagConstraints.BOTH;
        // Utiliser Insets pour ajouter un peu d'espace autour des panneaux de main
        gbc.insets = new Insets(5, 5, 5, 5);


        // Joueur 1 (Bas) - Toujours présent (joueur actuel)
        // Simule une main de 7 cartes pour le joueur 1
        JPanel player1Panel = setupHandPanel(0, 7);
        gbc.gridx = 1;
        gbc.gridy = 2;
        gbc.anchor = GridBagConstraints.PAGE_END;
        mainPanel.add(player1Panel, gbc);

        // Joueur 2 (Haut) - Toujours présent
        // Simule une main de 7 cartes (dos visible)
        JPanel player2Panel = setupHandPanel(1, 7);
        gbc.gridx = 1;
        gbc.gridy = 0;
        gbc.anchor = GridBagConstraints.PAGE_START;
        mainPanel.add(player2Panel, gbc);

        // Joueur 3 (Gauche) - Conditionnel
        if (numPlayers >= 3) {
             // Simule une main de 5 cartes (dos visible)
            JPanel player3Panel = setupHandPanel(2, 5);
            gbc.gridx = 0;
            gbc.gridy = 1;
            gbc.anchor = GridBagConstraints.LINE_START;
            mainPanel.add(player3Panel, gbc);
        }

        // Joueur 4 (Droite) - Conditionnel
        if (numPlayers == 4) {
             // Simule une main de 6 cartes (dos visible)
            JPanel player4Panel = setupHandPanel(3, 6);
            gbc.gridx = 2;
            gbc.gridy = 1;
            gbc.anchor = GridBagConstraints.LINE_END;
            mainPanel.add(player4Panel, gbc);
        }
    }

    // Crée le panneau central avec JLayeredPane pour la pioche et la défausse
    private JPanel setupCenterPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setOpaque(false); // Rendre le panneau transparent pour voir le fond du mainPanel

        // Utiliser JLayeredPane pour la pioche et la défausse
        JLayeredPane centerPane = new JLayeredPane();
        centerPane.setPreferredSize(new Dimension(300, 150));
        centerPane.setOpaque(false); // Rendre le layered pane transparent

        // Pioche (dos de carte) - Utilise le loader pour obtenir l'image
        JLabel drawPile = createFancyCardLabel("", null, "dos"); // Pas besoin de valeur/couleur pour le dos
        drawPile.setBounds(100, 25, CARD_WIDTH, CARD_HEIGHT);
        centerPane.add(drawPile, JLayeredPane.DEFAULT_LAYER);

        // Défausse - avec une carte initiale (simulée) - Utilise le loader
        // Utilisons une carte spécifique pour l'exemple initial
        JLabel discardPile = createFancyCardLabel("4", Color.BLUE, "nombre");
        discardPile.setBounds(200, 25, CARD_WIDTH, CARD_HEIGHT);
        centerPane.add(discardPile, JLayeredPane.DEFAULT_LAYER);

        // Ajouter le layeredPane au centre du panneau central
        panel.add(centerPane, BorderLayout.CENTER);

        // Ajouter un panneau informatif (tour actuel, direction, etc.)
        JPanel infoPanel = new JPanel();
        infoPanel.setOpaque(false); // Rendre le panneau info transparent
        infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));
        infoPanel.setBorder(new EmptyBorder(10, 0, 0, 0)); // Ajouter un peu d'espace au-dessus

        JLabel turnLabel = new JLabel("Tour: " + playerNames[0]);
        turnLabel.setForeground(Color.WHITE);
        turnLabel.setFont(new Font("Arial", Font.BOLD, 14));
        turnLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        JLabel directionLabel = new JLabel("Direction: ↻ Horaire");
        directionLabel.setForeground(Color.WHITE);
        directionLabel.setFont(new Font("Arial", Font.BOLD, 14));
        directionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        infoPanel.add(turnLabel);
        infoPanel.add(Box.createVerticalStrut(5));
        infoPanel.add(directionLabel);

        panel.add(infoPanel, BorderLayout.SOUTH);

        // Changement de couleur du fond selon la carte du dessus (défausse)
        updateBackgroundColorFromCard(discardPile);

        return panel;
    }

    // Méthode pour mettre à jour le fond en fonction de la carte jouée sur la défausse
    private void updateBackgroundColorFromCard(JLabel cardLabel) {
        if (cardLabel == null) return;

        // Récupérer la couleur stockée dans les propriétés client
        Color cardColor = (Color) cardLabel.getClientProperty("cardColor");
        String cardType = (String) cardLabel.getClientProperty("cardType");


        // Pour les jokers (wild, +4), la couleur est noire/grise sur l'image,
        // mais la couleur du jeu change selon la couleur choisie par le joueur.
        // Ici, on utilise la couleur stockée, qui devrait être la couleur *effective* de la carte sur la défausse.

        if (cardColor != null && !cardColor.equals(Color.BLACK) && !cardColor.equals(Color.DARK_GRAY)) {
            // Créer une version plus sombre de la couleur de la carte
            Color bgColor = new Color(
                    Math.max(cardColor.getRed() - 80, 0), // Rendre un peu plus sombre
                    Math.max(cardColor.getGreen() - 80, 0),
                    Math.max(cardColor.getBlue() - 80, 0)
            );
            mainPanel.setBackgroundColor(bgColor);
        } else if (cardColor != null && (cardColor.equals(Color.BLACK) || cardColor.equals(Color.DARK_GRAY)) && !"dos".equals(cardType)) {
             // Si c'est un joker noir joué (pas le dos), on pourrait utiliser une couleur par défaut ou garder le vert
             mainPanel.setBackgroundColor(new Color(0, 80, 0)); // Un vert légèrement différent ou autre couleur neutre
        }
        // Si c'est le dos de carte (défausse vide ou début de jeu, bien que la défausse ait une carte initiale ici), garder le vert par défaut
         else if ("dos".equals(cardType)) {
             mainPanel.setBackgroundColor(new Color(0, 100, 0)); // Le vert du tapis de jeu
         } else {
              // Cas d'une carte avec couleur null (ex: joker non coloré sur la défausse)
              mainPanel.setBackgroundColor(new Color(0, 90, 0)); // Une couleur neutre
         }
    }

    // Méthode pour mettre à jour la défausse avec une nouvelle carte jouée
    // Prend les propriétés de la carte à afficher sur la défausse
    public void updateDiscardPile(String value, Color color, String type) {
        // Trouver la défausse dans le panneau central
        Component[] centerComps = mainPanel.getComponents();
        JPanel centerPanel = null;

        // Rechercher le panneau central
        for (Component comp : centerComps) {
            if (comp instanceof JPanel &&
                ((GridBagLayout)mainPanel.getLayout()).getConstraints(comp).gridx == 1 &&
                ((GridBagLayout)mainPanel.getLayout()).getConstraints(comp).gridy == 1) {
                centerPanel = (JPanel)comp;
                break;
            }
        }

        if (centerPanel != null) {
            // Trouver le JLayeredPane contenant la pioche et la défausse
            JLayeredPane centerPane = null;
            for (Component comp : centerPanel.getComponents()) {
                if (comp instanceof JLayeredPane) {
                    centerPane = (JLayeredPane)comp;
                    break;
                }
            }

            if (centerPane != null) {
                // Trouver l'ancienne carte de défausse par sa position
                JLabel oldDiscardCard = null;
                 for (Component comp : centerPane.getComponents()) {
                    // On cherche un JLabel à la position de la défausse (200, 25)
                    // On peut aussi vérifier le type ou une propriété spéciale si plusieurs JLabels sont à cette position
                     if (comp instanceof JLabel && comp.getBounds().x == 200 && comp.getBounds().y == 25) {
                         oldDiscardCard = (JLabel) comp;
                         break;
                     }
                 }

                // Supprimer l'ancienne carte de défausse si trouvée
                if (oldDiscardCard != null) {
                    centerPane.remove(oldDiscardCard);
                }

                // Créer la nouvelle carte de défausse (face visible) en utilisant createFancyCardLabel
                JLabel newDiscardCard = createFancyCardLabel(value, color, type);

                // Configurer la position de la nouvelle carte sur la défausse
                newDiscardCard.setBounds(200, 25, CARD_WIDTH, CARD_HEIGHT);

                // Ajouter la nouvelle carte à la défausse (au même niveau que l'ancienne)
                centerPane.add(newDiscardCard, JLayeredPane.DEFAULT_LAYER);

                // Mettre à jour la couleur du fond en fonction de la nouvelle carte
                updateBackgroundColorFromCard(newDiscardCard);

                // Forcer la mise à jour de l'affichage
                centerPane.revalidate();
                centerPane.repaint();
                mainPanel.revalidate();
                mainPanel.repaint();
            }
        }
    }


    // Crée le panneau de main pour un joueur avec JLayeredPane et effet d'éventail
    private JPanel setupHandPanel(int playerIndex, int numCards) {
        JPanel outerPanel = new JPanel(new BorderLayout());
        outerPanel.setOpaque(false);

        // Créer un JLayeredPane pour les cartes en éventail
        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setOpaque(false);

        boolean isHorizontal = (playerIndex == 0 || playerIndex == 1);

        // Calculer la dimension du layeredPane selon l'orientation
        int panelWidth, panelHeight;

        if (isHorizontal) {
            // L'éventail horizontal a besoin de plus d'espace sur les côtés
            // Ajuster la taille pour bien contenir l'éventail
            panelWidth = CARD_WIDTH * 2 + (numCards > 1 ? (int) ((numCards - 1) * CARD_WIDTH * 0.3) : 0) + 50;
            panelHeight = CARD_HEIGHT + 50; // Espace pour l'arc et le décalage de sélection
        } else {
            // L'éventail vertical
             panelWidth = CARD_WIDTH + 50; // Espace pour l'arc et le décalage de sélection
             // Ajuster la taille pour bien contenir l'éventail
             panelHeight = CARD_HEIGHT * 2 + (numCards > 1 ? (int) ((numCards - 1) * CARD_HEIGHT * 0.3) : 0) + 50;
        }

        // S'assurer que les dimensions minimales sont respectées
         panelWidth = Math.max(panelWidth, CARD_WIDTH + 50);
         panelHeight = Math.max(panelHeight, CARD_HEIGHT + 50);


        layeredPane.setPreferredSize(new Dimension(panelWidth, panelHeight));
        layeredPane.setMinimumSize(new Dimension(CARD_WIDTH + 50, CARD_HEIGHT + 50)); // Minimum pour que ça s'affiche

        // Disposer les cartes en éventail
        positionCardsInFan(layeredPane, numCards, playerIndex);

        // Mettre en place le panneau avec le nom du joueur
        JPanel playerInfoPanel = new JPanel();
        playerInfoPanel.setOpaque(false);
        playerInfoPanel.setLayout(new BoxLayout(playerInfoPanel, BoxLayout.Y_AXIS));

        // Affichage du nom du joueur
        JLabel nameLabel = new JLabel(playerNames[playerIndex]);
        nameLabel.setForeground(Color.WHITE);
        nameLabel.setFont(new Font("Arial", Font.BOLD, 14));
        nameLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Nombre de cartes restantes
        // On pourrait récupérer le nombre réel de cartes du modèle ici
        JLabel cardCountLabel = new JLabel(numCards + " cartes");
        cardCountLabel.setForeground(Color.WHITE);
        cardCountLabel.setFont(new Font("Arial", Font.ITALIC, 12));
        cardCountLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        playerInfoPanel.add(nameLabel);
        playerInfoPanel.add(Box.createVerticalStrut(2));
        playerInfoPanel.add(cardCountLabel);

        // Placement des éléments selon la position du joueur
        if (playerIndex == 0) { // Joueur en bas
            outerPanel.add(layeredPane, BorderLayout.CENTER);
            outerPanel.add(playerInfoPanel, BorderLayout.SOUTH);
            playerInfoPanel.setBorder(new EmptyBorder(5, 0, 0, 0)); // Espace au-dessus du texte
        } else if (playerIndex == 1) { // Joueur en haut
            outerPanel.add(layeredPane, BorderLayout.CENTER);
            outerPanel.add(playerInfoPanel, BorderLayout.NORTH);
            playerInfoPanel.setBorder(new EmptyBorder(0, 0, 5, 0)); // Espace en-dessous du texte
        } else if (playerIndex == 2) { // Joueur à gauche
            outerPanel.add(layeredPane, BorderLayout.CENTER);
            outerPanel.add(playerInfoPanel, BorderLayout.WEST);
            playerInfoPanel.setBorder(new EmptyBorder(0, 5, 0, 0)); // Espace à droite du texte
             playerInfoPanel.setLayout(new BoxLayout(playerInfoPanel, BoxLayout.X_AXIS)); // Disposer nom et count côte à côte (verticale serait trop étroit)
             nameLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
             cardCountLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
             playerInfoPanel.add(Box.createHorizontalStrut(5)); // Espace entre nom et count
        } else { // Joueur à droite
            outerPanel.add(layeredPane, BorderLayout.CENTER);
            outerPanel.add(playerInfoPanel, BorderLayout.EAST);
             playerInfoPanel.setBorder(new EmptyBorder(0, 0, 0, 5)); // Espace à gauche du texte
             playerInfoPanel.setLayout(new BoxLayout(playerInfoPanel, BoxLayout.X_AXIS)); // Disposer nom et count côte à côte
             nameLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
             cardCountLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
             playerInfoPanel.add(Box.createHorizontalStrut(5)); // Espace entre nom et count
        }

        // Ajouter une bordure pour délimiter l'espace du joueur (optionnel)
        // outerPanel.setBorder(BorderFactory.createLineBorder(Color.GRAY)); // Utile pour le débogage du layout

        return outerPanel;
    }

    // Disposer les cartes en éventail avec images
    private void positionCardsInFan(JLayeredPane pane, int numCards, int playerIndex) {
        pane.removeAll(); // Nettoyer les cartes précédentes si nécessaire
        if (numCards == 0) {
             pane.revalidate();
             pane.repaint();
             return;
        }

        boolean isHorizontal = (playerIndex == 0 || playerIndex == 1);
        boolean showCardFace = (playerIndex == 0); // Seul le joueur actuel voit ses cartes

        // Centre du panneau où les cartes pivotent
        int pivotX = pane.getPreferredSize().width / 2;
        int pivotY = pane.getPreferredSize().height - CARD_HEIGHT/2 - 10; // Pivot près du bas pour joueur 0
        int verticalPivotX = CARD_WIDTH/2 + 10; // Pivot près de la gauche pour joueur 2
        int verticalPivotY = pane.getPreferredSize().height / 2;

        // Calculer l'angle entre chaque carte
        double angleStep = 0;
        if (numCards > 1) {
            angleStep = FAN_ANGLE / (double)(numCards - 1);
        }

        // Angle de départ (centré)
        double startAngle = -FAN_ANGLE / 2.0;

        for (int i = 0; i < numCards; i++) {
            // Simuler les propriétés de la carte (en réalité, viendrait du modèle de jeu)
            // Pour l'exemple, on alterne les couleurs et valeurs
            // Assurez-vous d'avoir des images correspondantes dans le dossier 'images'
            Color cardColor = CARD_COLORS[i % CARD_COLORS.length];
            String cardValue = CARD_VALUES[i % CARD_VALUES.length];
            String cardType = CARD_TYPES[i % CARD_TYPES.length];


            JLabel cardLabel;
            if (showCardFace) {
                 // Utilise createFancyCardLabel pour obtenir le JLabel avec l'image
                 cardLabel = createFancyCardLabel(cardValue, cardColor, cardType);
            } else {
                 // Dos de carte pour les adversaires - Utilise createFancyCardLabel avec type "dos"
                 cardLabel = createFancyCardLabel("", null, "dos");
            }

            // Stocker les propriétés de la carte comme propriétés client (utile pour la défausse, le survol, etc.)
            // Ces propriétés sont déjà mises dans createFancyCardLabel
            // cardLabel.putClientProperty("cardValue", cardValue);
            // cardLabel.putClientProperty("cardColor", cardColor);
            // cardLabel.putClientProperty("cardType", cardType);


            // Calculer l'angle pour cette carte
            double angle = startAngle + (i * angleStep);

            // Appliquer la rotation - Utilisez le RotatingCardLabel
            RotatingCardLabel rotatingCardLabel = new RotatingCardLabel(cardLabel.getIcon(), angle, isHorizontal ? 0 : 90); // Rotation de 0 pour horizontal, 90 pour vertical

             // Copier les propriétés client du JLabel créé au RotatingCardLabel
             // car les listeners et updateBackgroundColorFromCard utilisent ces propriétés
             rotatingCardLabel.putClientProperty("cardValue", cardLabel.getClientProperty("cardValue"));
             rotatingCardLabel.putClientProperty("cardColor", cardLabel.getClientProperty("cardColor"));
             rotatingCardLabel.putClientProperty("cardType", cardLabel.getClientProperty("cardType"));


            // Calculer la position basée sur l'angle (c'est la partie délicate pour l'effet éventail)
            Point position = new Point();

            if (isHorizontal) {
                // Pour les joueurs en haut et en bas
                 int radius = (int)(pane.getPreferredSize().width * 0.4); // Rayon de l'arc
                 double angleRad = Math.toRadians(angle);
                 position.x = pivotX + (int) (Math.sin(angleRad) * radius);
                 int yOffset = playerIndex == 0 ? 0 : pane.getPreferredSize().height - CARD_HEIGHT - 20; // Ajuster pour le joueur en haut
                 position.y = yOffset + (int) (Math.cos(angleRad) * (radius * 0.3));
                 position.x += (pane.getPreferredSize().width/2) - pivotX - (int)(Math.sin(0) * radius); // Ajuster pour centrer l'éventail
                 position.y += (playerIndex == 0 ? pane.getPreferredSize().height - CARD_HEIGHT - 10 : 10) - yOffset - (int)(Math.cos(0) * (radius * 0.3)); // Ajuster pour placer la base de l'éventail

            } else {
                 // Pour les joueurs à gauche et à droite (éventail vertical)
                 int radius = (int)(pane.getPreferredSize().height * 0.4); // Rayon de l'arc vertical
                 double angleRad = Math.toRadians(angle);
                 position.y = verticalPivotY + (int) (Math.sin(angleRad) * radius);
                 int xOffset = playerIndex == 2 ? 0 : pane.getPreferredSize().width - CARD_WIDTH - 20; // Ajuster pour le joueur à droite
                 position.x = xOffset + (int) (Math.cos(angleRad) * (radius * 0.3));
                 position.y += (pane.getPreferredSize().height/2) - verticalPivotY - (int)(Math.sin(0) * radius);
                 position.x += (playerIndex == 2 ? CARD_WIDTH + 10 : pane.getPreferredSize().width - CARD_WIDTH - 10) - xOffset - (int)(Math.cos(0) * (radius * 0.3));
            }


            // Positionner la carte (les bounds définissent la zone du composant *avant* rotation)
            // On positionne le centre de la carte à la position calculée
             int cardDrawX = position.x - CARD_WIDTH / 2;
             int cardDrawY = position.y - CARD_HEIGHT / 2;

            rotatingCardLabel.setBounds(cardDrawX, cardDrawY, CARD_WIDTH, CARD_HEIGHT);


            // Ajouter au layeredPane (avec indices de profondeur pour la superposition)
            // L'indice de profondeur assure que les cartes à droite/bas de l'éventail sont au-dessus
            pane.add(rotatingCardLabel, Integer.valueOf(i));

            // Ajouter un écouteur d'événements pour la carte du joueur actuel
            if (playerIndex == 0) {
                final int cardIndex = i;
                final RotatingCardLabel finalCardLabel = rotatingCardLabel; // Pour utiliser dans l'écouteur
                final Point originalLocation = new Point(cardDrawX, cardDrawY); // Stocker la position originale


                rotatingCardLabel.addMouseListener(new java.awt.event.MouseAdapter() {
                    @Override
                    public void mouseClicked(java.awt.event.MouseEvent evt) {
                        // Effet de sélection - soulever la carte quand cliquée
                         // Remettre les autres cartes soulevées à leur place d'origine (simplification)
                         for (Component comp : pane.getComponents()) {
                             if (comp instanceof RotatingCardLabel) {
                                 RotatingCardLabel rc = (RotatingCardLabel) comp;
                                  if (rc != finalCardLabel) {
                                       // Remettre à la position Y originale stockée
                                       Point compOriginalLocation = (Point)rc.getClientProperty("originalLocation");
                                       if (compOriginalLocation != null && rc.getY() < compOriginalLocation.y) {
                                            rc.setLocation(compOriginalLocation.x, compOriginalLocation.y);
                                            pane.repaint();
                                       }
                                  }
                             }
                         }

                        // Stocker la position originale si ce n'est pas déjà fait
                         if (finalCardLabel.getClientProperty("originalLocation") == null) {
                             finalCardLabel.putClientProperty("originalLocation", originalLocation);
                         }


                         // Soulever/Baisser la carte cliquée
                         Point currentOriginalLocation = (Point)finalCardLabel.getClientProperty("originalLocation");
                         if (finalCardLabel.getY() == currentOriginalLocation.y) { // Si elle n'est pas déjà soulevée
                             finalCardLabel.setLocation(currentOriginalLocation.x, currentOriginalLocation.y - 15); // Soulever de 15 pixels
                         } else {
                             // Baisser la carte si elle est déjà soulevée
                             finalCardLabel.setLocation(currentOriginalLocation.x, currentOriginalLocation.y);
                         }
                         pane.repaint(); // Redessiner pour le changement de position

                        System.out.println("Carte cliquée - Index: " + cardIndex + ", Valeur: " + finalCardLabel.getClientProperty("cardValue") + ", Couleur: " + finalCardLabel.getClientProperty("cardColor"));

                        // *** SIMULATION DE JEU DE CARTE ***
                        // Dans un vrai jeu, on vérifierait si la carte est jouable
                        // et on notifierait le contrôleur/modèle.
                        // Ici, pour la démonstration, on simule le jeu sur la défausse
                        String playedValue = (String) finalCardLabel.getClientProperty("cardValue");
                        Color playedColor = (Color) finalCardLabel.getClientProperty("cardColor");
                        String playedType = (String) finalCardLabel.getClientProperty("cardType");

                        // On vérifie si l'icône existe avant de simuler le jeu
                        if (finalCardLabel.getIcon() != null) {
                             updateDiscardPile(playedValue, playedColor, playedType); // Mettre à jour la défausse

                             // Retirer la carte jouée de la main du joueur (visuellement)
                             pane.remove(finalCardLabel);
                             // Recalculer les positions pour re-faire l'éventail (simplifié)
                             // Dans une vraie application, il faudrait stocker la main et rappeler positionCardsInFan
                             // avec la nouvelle liste de cartes. Ici, on retire juste le composant.
                             // On ne va pas recalculer l'éventail ici pour rester simple dans cette modification,
                             // mais c'est la prochaine étape pour un affichage correct.
                             // Pour l'instant, ça laisse un trou.
                             pane.revalidate(); // Recalculer le layout (ne re-fait pas l'éventail)
                             pane.repaint(); // Redessiner la main
                        } else {
                             System.out.println("Impossible de jouer la carte (image non chargée)");
                        }


                    }

                    @Override
                    public void mouseEntered(java.awt.event.MouseEvent evt) {
                        // Effet de survol - soulève légèrement la carte ou change la bordure
                         // On ne soulève pas si la carte est déjà soulevée par un clic
                         Point currentOriginalLocation = (Point)finalCardLabel.getClientProperty("originalLocation");
                         if (currentOriginalLocation != null && finalCardLabel.getY() == currentOriginalLocation.y) {
                             finalCardLabel.setLocation(currentOriginalLocation.x, currentOriginalLocation.y - 5); // Soulève de 5 pixels
                             finalCardLabel.setBorder(BorderFactory.createLineBorder(Color.YELLOW, 2)); // Change la bordure
                             pane.repaint();
                         } else if (currentOriginalLocation == null) {
                             // Cas initial avant le premier clic
                              finalCardLabel.setLocation(finalCardLabel.getX(), finalCardLabel.getY() - 5);
                              finalCardLabel.setBorder(BorderFactory.createLineBorder(Color.YELLOW, 2));
                              // Stocker la position initiale si ce n'est pas déjà fait
                             if (finalCardLabel.getClientProperty("originalLocation") == null) {
                                 finalCardLabel.putClientProperty("originalLocation", new Point(finalCardLabel.getX(), finalCardLabel.getY() + 5)); // Stocke la position de base
                             }
                              pane.repaint();
                         } else {
                             // La carte est déjà soulevée par un clic, juste changer la bordure
                             finalCardLabel.setBorder(BorderFactory.createLineBorder(Color.YELLOW, 2));
                         }
                    }

                    @Override
                    public void mouseExited(java.awt.event.MouseEvent evt) {
                        // Retour à la normale
                         finalCardLabel.setBorder(BorderFactory.createEmptyBorder()); // Supprimer la bordure
                         // On ne remet à la place d'origine que si elle a été soulevée par survol (5px)
                         Point currentOriginalLocation = (Point)finalCardLabel.getClientProperty("originalLocation");
                          // On vérifie si la position actuelle est celle du survol (original Y - 5)
                         if (currentOriginalLocation != null && finalCardLabel.getY() == currentOriginalLocation.y - 5) {
                             finalCardLabel.setLocation(currentOriginalLocation.x, currentOriginalLocation.y);
                             pane.repaint();
                         }
                    }
                });
            }
        }

        // Forcer le layout et le dessin après avoir ajouté toutes les cartes
        pane.revalidate();
        pane.repaint();
    }

    // Crée une carte stylisée en demandant l'image au loader
    private JLabel createFancyCardLabel(String value, Color color, String type) {
        JLabel card = new JLabel();

        // Demande l'icône au loader d'images
        ImageIcon icon = imageLoader.getScaledIcon(value, color, type);

        if (icon != null) {
            card.setIcon(icon);
            card.setPreferredSize(new Dimension(CARD_WIDTH, CARD_HEIGHT));
            card.setOpaque(false); // Important pour que les couches du JLayeredPane soient visibles
            // Pas de bordure par défaut, l'image en a généralement une

             // Stocker les propriétés de la carte comme propriétés client
             card.putClientProperty("cardValue", value); // Stocker la valeur
             card.putClientProperty("cardColor", color); // Stocker la couleur réelle (pour le fond)
             card.putClientProperty("cardType", type); // Stocker le type (pour le fond et la logique)

        } else {
            // Gérer le cas où le loader n'a pas pu charger l'image
            System.err.println("Erreur: Impossible d'obtenir l'icône pour: type=" + type + ", valeur=" + value + ", couleur=" + color);
            card.setPreferredSize(new Dimension(CARD_WIDTH, CARD_HEIGHT));
            card.setBackground(Color.PINK); // Couleur d'erreur
            card.setOpaque(true);
            card.setText("ERR"); // Texte d'erreur
            card.setHorizontalAlignment(SwingConstants.CENTER);
            card.setVerticalAlignment(SwingConstants.CENTER);
            card.setBorder(BorderFactory.createLineBorder(Color.RED, 2)); // Bordure d'erreur

            // Stocker des valeurs null ou par défaut pour les propriétés client en cas d'erreur
             card.putClientProperty("cardValue", "ERR");
             card.putClientProperty("cardColor", null);
             card.putClientProperty("cardType", "error"); // Un type "error" pour le débogage
        }

        return card;
    }

    // Classe interne pour un JLabel qui peut être tourné (reste dans la vue)
     private static class RotatingCardLabel extends JLabel {
         private double angle; // Angle de rotation en degrés par rapport à l'orientation
         private int orientationAngle; // 0 pour horizontal, 90 pour vertical (rotation de base)

         public RotatingCardLabel(Icon icon, double angle, int orientationAngle) {
             super(icon);
             this.angle = angle;
             this.orientationAngle = orientationAngle;
             setOpaque(false); // Important
             // Ne pas définir la taille ici, elle sera définie par setBounds dans positionCardsInFan
         }

         @Override
         protected void paintComponent(Graphics g) {
             // Peindre le fond si opaque est true (pas notre cas ici)
             // super.paintComponent(g);

             Graphics2D g2d = (Graphics2D) g.create();

             // Activer l'antialiasing pour une meilleure qualité de rotation
             g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
             g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);

             // Calculer le centre du composant pour la rotation
             int centerX = getWidth() / 2;
             int centerY = getHeight() / 2;

             // Appliquer la transformation de rotation
             // On combine l'angle de l'éventail et l'angle d'orientation
             AffineTransform at = AffineTransform.getRotateInstance(
                 Math.toRadians(angle + orientationAngle), centerX, centerY);
             g2d.transform(at);

             // Peindre l'icône APRES la transformation
             // Le getIcon() est hérité de JLabel, il utilise l'icône qu'on lui a settée
             Icon icon = getIcon();
             if (icon != null) {
                 icon.paintIcon(this, g2d, 0, 0); // Peint l'icône à la position 0,0 (après transformation)
             } else {
                 // Optionnel: peindre quelque chose si l'icône est nulle (utile pour le débogage)
                 g2d.setColor(Color.RED);
                 g2d.fillRect(0, 0, getWidth(), getHeight());
                 g2d.setColor(Color.BLACK);
                 g2d.drawString("No Icon", 5, getHeight()/2);
             }


             // Ne pas appeler super.paintComponent(g2d); ici car on gère le dessin de l'icône nous-mêmes

             // Nettoyer le contexte graphique
             g2d.dispose();
         }

         // Redéfinir getPreferredSize si nécessaire (JLabel.getPreferredSize() utilise déjà l'icône si elle est définie)
         // @Override
         // public Dimension getPreferredSize() {
         //     Icon icon = getIcon();
         //     if (icon != null) {
         //         return new Dimension(icon.getIconWidth(), icon.getIconHeight());
         //     } else {
         //         return super.getPreferredSize();
         //     }
         // }
     }


}
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Deck {
    private List<Card> cards;

    public Deck() {
        cards = new ArrayList<>();
        initializeDeck();
        shuffle();
    }

    private void initializeDeck() {
        String[] colors = {"Red", "Yellow", "Green", "Blue"};
        String[] numbers = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
        String[] actions = {"skip", "reverse", "draw_2"};

        // Cartes numérotées
        for (String color : colors) {
            // Une carte 0 par couleur
            cards.add(new Card (color, "0"));
            // Deux cartes de chaque nombre de 1 à 9 par couleur
            for (int i = 1; i <= 9; i++) {
                cards.add(new Card(color, String.valueOf(i)));
                cards.add(new Card(color, String.valueOf(i)));
            }
        }

        // Cartes spéciales
        for (String color : colors) {
            for (String action : actions) {
                // Deux cartes de chaque action par couleur
                cards.add(new Card(color, action));
                cards.add(new Card(color, action));
            }
        }

        // Cartes jokers
        for (int i = 0; i < 4; i++) {
            cards.add(new Card("Wild", "Wild"));
            cards.add(new Card("Wild", "Wild_draw_4"));
        }
    }

    public void shuffle() {
        Collections.shuffle(cards);
    }

    public Card drawCard() {
        if (!cards.isEmpty()) {
            return cards.remove(0);
        } else {
            return null; // Le deck est vide
        }
    }

    public List<Card> getCards() {
        return cards;
    }
}
import javax.swing.*;
import java.io.File;

public class Card {
    private String color;
    private String value;
    private String imageName;
    private ImageIcon image;

    // Nouveau chemin avec le bon dossier + barre finale
    private static final String IMAGE_PATH = "C:\\Users\\manel\\OneDrive\\Bureau\\cartesuno\\cards\\";

    public Card(String color, String value) {
        this.color = color;
        this.value = value;
        this.imageName = generateImageName();
        this.image = loadImage();
    }
     // Taille des cartes redimensionnées (ex: 100x150 pixels)
    private static final int CARD_WIDTH = 50;
    private static final int CARD_HEIGHT = 50;

    // Génère le bon nom d’image avec .jpg
    private String generateImageName() {
        if (color.equalsIgnoreCase("Wild")) {
            return value + ".jpg"; // ex : "Wild.jpg"
        } else {
            return color + "_" + value + ".jpg"; // ex : "Blue_5.jpg"
        }
    }

    // Charge l'image depuis le chemin complet
    private ImageIcon loadImage() {
        String fullPath = IMAGE_PATH + imageName;
        File imageFile = new File(fullPath);
        if (imageFile.exists()) {
            return new ImageIcon(fullPath);
        } else {
            System.err.println("Image non trouvée : " + fullPath);
            return null;
        }
    }

    public String getColor() {
        return color;
    }

    public String getValue() {
        return value;
    }

    public ImageIcon getImage() {
        return image;
    }

    @Override
    public String toString() {
        return color + " " + value;
    }
}

